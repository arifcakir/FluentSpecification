using System;
using System.Linq.Expressions;
using FluentSpecification.Abstractions;
using FluentSpecification.Abstractions.Generic;
using FluentSpecification.Abstractions.Validation;
using FluentSpecification.Core.Validation;
using JetBrains.Annotations;

namespace FluentSpecification.Core
{
    /// <summary>
    ///     Internal adapter, extends <c>Specification</c> object to complex <c>Specification</c>.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    internal sealed class SpecificationAdapter<T> :
        IComplexSpecification<T>,
        INegatableValidationSpecification<T>,
        INegatableLinqSpecification<T>
    {
        private readonly ISpecification<T> _baseSpecification;

        /// <summary>
        ///     Creates adapter.
        /// </summary>
        /// <param name="specification">Base non-complex <c>Specification</c>.</param>
        /// <exception cref="ArgumentException">
        ///     Thrown when <c>Specification</c> already implements
        ///     <see cref="IComplexSpecification{T}" />
        /// </exception>
        public SpecificationAdapter([NotNull] ISpecification<T> specification)
        {
            _baseSpecification = specification ?? throw new ArgumentNullException(nameof(specification));
            if (specification is IComplexSpecification<T>)
                throw new ArgumentException("Incorrect specification type", nameof(specification));
        }

        /// <inheritdoc />
        public bool IsSatisfiedBy(T candidate)
        {
            return _baseSpecification.IsSatisfiedBy(candidate);
        }

        /// <summary>
        ///     Checks if <c>Specification</c> is satisfied by <paramref name="candidate" /> object.
        ///     Returns validation <paramref name="result" /> no matter is satisfied or not.
        /// </summary>
        /// <remarks>
        ///     If base <c>Specification</c> is not <see cref="IValidationSpecification{T}" /> -
        ///     <paramref name="result" /> is generated by adapter.
        /// </remarks>
        /// <param name="candidate">Candidate object to verification.</param>
        /// <param name="result">
        ///     Contains validation summary - errors, types of all executed <c>Specifications</c>
        ///     and trace message in the style of Boole algebra.
        /// </param>
        /// <returns>
        ///     <para>true - <c>Specification</c> is satisfied by <paramref name="candidate" />.</para>
        ///     <para>false - is not. <paramref name="result" /> should contains errors.</para>
        /// </returns>
        public bool IsSatisfiedBy(T candidate, out SpecificationResult result)
        {
            if (_baseSpecification is IValidationSpecification<T> specification)
                return specification.IsSatisfiedBy(candidate, out result);

            var overall = IsSatisfiedBy(candidate);

            result = CreateResult(candidate, overall, false);

            return overall;
        }

        /// <summary>
        ///     Gets typed lambda <c>Linq</c> Expression with candidate object verification.
        /// </summary>
        /// <remarks>
        ///     If base <c>Specification</c> is not <see cref="ILinqSpecification{T}" /> -
        ///     <c>Expression</c> is generated by adapter (as <see cref="IsSatisfiedBy(T)" /> invoke).
        /// </remarks>
        /// <returns>Strongly typed lambda <c>Linq</c> Expression.</returns>
        public Expression<Func<T, bool>> GetExpression()
        {
            if (_baseSpecification is ILinqSpecification<T> specification) return specification.GetExpression();

            return GetExpression(false);
        }

        /// <inheritdoc />
        Expression ILinqSpecification.GetExpression()
        {
            return GetExpression();
        }

        /// <summary>
        ///     Gets typed lambda <c>Linq</c> Expression with candidate object verification.
        /// </summary>
        /// <remarks>
        ///     If base <c>Specification</c> is not <see cref="INegatableLinqSpecification{T}" /> -
        ///     <c>Expression</c> is generated by adapter.
        /// </remarks>
        /// <returns>Strongly typed lambda <c>Linq</c> Expression.</returns>
        public Expression<Func<T, bool>> GetNegationExpression()
        {
            if (_baseSpecification is INegatableLinqSpecification<T> negatableSpecification)
                return negatableSpecification.GetNegationExpression();

            return GetExpression(true);
        }

        /// <summary>
        ///     Checks if <c>Specification</c> is NOT satisfied by <paramref name="candidate" /> object.
        /// </summary>
        /// <remarks>
        ///     If base <c>Specification</c> is not <see cref="INegatableSpecification{T}" /> -
        ///     result is generated by negation of <see cref="IsSatisfiedBy(T)" />.
        /// </remarks>
        /// <param name="candidate">Candidate object to verification.</param>
        /// <returns>
        ///     <para>true - <c>Specification</c> is NOT satisfied by <paramref name="candidate" />.</para>
        ///     <para>false - is satisfied.</para>
        /// </returns>
        public bool IsNotSatisfiedBy(T candidate)
        {
            if (_baseSpecification is INegatableSpecification<T> negatableSpecification)
                return negatableSpecification.IsNotSatisfiedBy(candidate);
            return !IsSatisfiedBy(candidate);
        }

        /// <summary>
        ///     Checks if <c>Specification</c> is NOT satisfied by <paramref name="candidate" /> object.
        ///     Returns validation <paramref name="result" /> no matter is satisfied or not.
        /// </summary>
        /// <remarks>
        ///     If base <c>Specification</c> is not <see cref="INegatableValidationSpecification{T}" /> -
        ///     <paramref name="result" /> is generated by adapter.
        /// </remarks>
        /// <param name="candidate">Candidate object to verification.</param>
        /// <param name="result">
        ///     Contains validation summary - errors, types of all executed <c>Specifications</c>
        ///     and trace message in the style of Boole algebra.
        /// </param>
        /// <returns>
        ///     <para>true - <c>Specification</c> is NOT satisfied by <paramref name="candidate" />.</para>
        ///     <para>false - is satisfied. <paramref name="result" /> should contains errors.</para>
        /// </returns>
        public bool IsNotSatisfiedBy(T candidate, out SpecificationResult result)
        {
            if (_baseSpecification is INegatableValidationSpecification<T> negatableSpecification)
                return negatableSpecification.IsNotSatisfiedBy(candidate, out result);

            var overall = IsNotSatisfiedBy(candidate);

            result = CreateResult(candidate, overall, true);

            return overall;
        }

        [NotNull]
        private string CreateFailedMessage(bool isNegation)
        {
            if (!isNegation)
                return
                    $"Specification [{SpecificationResultGenerator.GetSpecificationShortName(_baseSpecification)}] is not satisfied by candidate";
            return
                $"Specification [{SpecificationResultGenerator.GetSpecificationShortName(_baseSpecification)}] is satisfied by candidate";
        }

        [NotNull]
        private string CreateTraceMessage(bool result, bool isNegation)
        {
            var message = SpecificationResultGenerator.GetSpecificationShortName(_baseSpecification);
            if (!result)
                message += "+Failed";

            if (isNegation)
                message = $"Not{message}";

            return message;
        }

        [NotNull]
        private SpecificationResult CreateResult([CanBeNull] T candidate, bool overall, bool isNegation)
        {
            var trace = CreateTraceMessage(overall, isNegation);
            var failedSpecifications = overall
                ? null
                : new[]
                {
                    new FailedSpecification(_baseSpecification.GetType(), null, candidate,
                        CreateFailedMessage(isNegation))
                };

            return new SpecificationResult(overall, trace, failedSpecifications);
        }

        [NotNull]
        private Expression<Func<T, bool>> GetExpression(bool negatable)
        {
            var arg = Expression.Parameter(typeof(T), "candidate");

            Func<T, bool> func;
            Expression callExpression;
            if (negatable && _baseSpecification is INegatableSpecification<T> negatableSpecification)
            {
                func = negatableSpecification.IsNotSatisfiedBy;
                callExpression = Expression.Call(Expression.Constant(_baseSpecification), func.Method, arg);
            }
            else
            {
                func = _baseSpecification.IsSatisfiedBy;
                if (negatable)
                    callExpression =
                        Expression.Not(Expression.Call(Expression.Constant(_baseSpecification), func.Method, arg));
                else
                    callExpression = Expression.Call(Expression.Constant(_baseSpecification), func.Method, arg);
            }

            return Expression.Lambda<Func<T, bool>>(callExpression, arg);
        }

        /// <summary>
        ///     Conversion operator from <c>Specification</c> to <see cref="Expression{Func}" />.
        /// </summary>
        /// <param name="self">Converted object</param>
        /// <exception cref="NullReferenceException">Thrown when <paramref name="self" /> is null.</exception>
        [PublicAPI]
        [NotNull]
        public static implicit operator Expression<Func<T, bool>>([NotNull] SpecificationAdapter<T> self)
        {
            return self.GetExpression();
        }

        /// <summary>
        ///     Conversion operator from <c>Specification</c> to <see cref="Func{T, Boolean}" />.
        /// </summary>
        /// <param name="self">Converted object</param>
        /// <exception cref="ArgumentException">Thrown when <paramref name="self" /> is null.</exception>
        [PublicAPI]
        [NotNull]
        public static implicit operator Func<T, bool>([NotNull] SpecificationAdapter<T> self)
        {
            return self.IsSatisfiedBy;
        }

        /// <summary>
        ///     Conversion operator from <c>Specification</c> to <see cref="Expression" />.
        /// </summary>
        /// <param name="self">Converted object</param>
        /// <exception cref="NullReferenceException">Thrown when <paramref name="self" /> is null.</exception>
        [PublicAPI]
        [NotNull]
        public static explicit operator Expression([NotNull] SpecificationAdapter<T> self)
        {
            return ((ILinqSpecification) self).GetExpression();
        }
    }
}